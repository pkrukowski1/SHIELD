from model.target_network.vit import IntervalViT
from model.model_abc import CLModuleABC
from typing import Tuple

import torch
import torch.nn as nn
from hypnettorch.hnets import HMLP


class HyperNetWithPretrainedViT(CLModuleABC):
    """
    HyperNetWithPretrainedViT is a continual learning module that leverages a conditional hypernetwork (HMLP)
    to generate task-specific parameters for a target Vision Transformer (ViT)-based network (IntervalViT).
    This design enables dynamic adaptation of the target network's weights based on the current task, 
    facilitating efficient multi-task or continual learning.
        target_network (IntervalViT): The main ViT-based network whose weights are generated by the hypernetwork.
        hnet (HMLP): The conditional hypernetwork responsible for producing the target network's weights
            based on a learned embedding for each task.
        learnable_params (iterable): The parameters of the hypernetwork, intended for optimization.
        no_classes_per_task (int): Number of output classes for each task.
        activation_function (nn.Module): Activation function used in both the hypernetwork and the target network.
        hnet_hidden_layers (Tuple[int, ...]): Sizes of the hidden layers in the hypernetwork (HMLP).
        target_hidden_layers (Tuple[int, ...]): Sizes of the hidden layers in the target ViT network.
        number_of_tasks (int): Total number of tasks, used to define the number of conditional embeddings.
        hnet_embedding_size (int): Dimensionality of the task embedding vector in the hypernetwork.
    Methods:
        forward(x: torch.Tensor, task_id: int, epsilon: torch.Tensor) -> Tuple[torch.Tensor, torch.Tensor]:
            Performs a forward pass by generating task-specific weights with the hypernetwork and applying
            them to the target ViT network. Returns the output logits and radii for the input batch.
                x (torch.Tensor): Input batch of images, shape (B, C, H, W).
                task_id (int): Identifier for the current task, used to select the task embedding.
                epsilon (torch.Tensor): Perturbation tensor for robust output computation.
                Tuple[torch.Tensor, torch.Tensor]: Output logits and radii from the target network.
    """
    
    def __init__(self, 
                 no_classes_per_task: int,
                 activation_function: nn.Module,
                 hnet_hidden_layers: Tuple[int, ...],
                 target_hidden_layers: Tuple[int, ...],
                 number_of_tasks: int,
                 hnet_embedding_size: int) -> None:
        """
        Initialize the HyperNetWithMLP module.

        Args:
            no_classes_per_task (int): Number of output classes per task.
            activation_function (nn.Module): Activation function used in both MLP and hypernetwork.
            hnet_hidden_layers (Tuple[int, ...]): Sizes of hidden layers in the hypernetwork.
            target_hidden_layers (Tuple[int, ...]): Sizes of hidden layers in the MLP target network.
            number_of_tasks (int): Number of distinct tasks (used for conditional embeddings).
            hnet_embedding_size (int): Dimensionality of task embeddings in the hypernetwork.
        """

        super().__init__()

        self.target_network = IntervalViT(
            n_out=no_classes_per_task,
            hidden_layers=target_hidden_layers,
            activation_fn=activation_function,
            use_bias=True,
            no_weights=True,
        )

        self.hnet = HMLP(
            self.target_network.param_shapes,
            uncond_in_size=0,
            cond_in_size=hnet_embedding_size,
            activation_fn=activation_function,
            layers=hnet_hidden_layers,
            num_cond_embs=number_of_tasks,
        )

        self.learnable_params = self.hnet.parameters()
        

    def forward(self, x: torch.Tensor, task_id: int, epsilon: torch.Tensor) -> Tuple[torch.Tensor, torch.Tensor]:
        """
        Perform a forward pass through the target network using weights generated 
        by the hypernetwork conditioned on the given task ID.

        Args:
            x (torch.Tensor): Input image batch of shape (B, C, H, W).
            epsilon (float): Perturbation value.
            task_id (int): ID of the current task, used to condition the hypernetwork.

        Returns:
            Tuple[torch.Tensor, float]: 
                - Output logits from the target network.
                - Output radii from the target_network.
        """
        hnet_weights = self.hnet.forward(cond_id=task_id)
        outputs, eps = self.target_network(
            x, epsilon=epsilon, weights=hnet_weights, condition=task_id
        )
        return outputs, eps
